package com.popups.pupoo.auth.application;

import com.popups.pupoo.auth.dto.LoginRequest;
import com.popups.pupoo.auth.dto.LoginResponse;
import com.popups.pupoo.auth.dto.RefreshTokenRequest;
import com.popups.pupoo.auth.dto.TokenResponse;
import com.popups.pupoo.auth.domain.model.RefreshToken;
import com.popups.pupoo.auth.persistence.RefreshTokenRepository;
import com.popups.pupoo.user.domain.model.User;
import com.popups.pupoo.user.persistence.UserRepository;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class AuthService {

    private final UserRepository userRepository;
    private final RefreshTokenRepository refreshTokenRepository;
    private final PasswordEncoder passwordEncoder;
    private final TokenService tokenService;

    public AuthService(UserRepository userRepository,
                       RefreshTokenRepository refreshTokenRepository,
                       PasswordEncoder passwordEncoder,
                       TokenService tokenService) {
        this.userRepository = userRepository;
        this.refreshTokenRepository = refreshTokenRepository;
        this.passwordEncoder = passwordEncoder;
        this.tokenService = tokenService;
    }

    // ✅ 백로그: login(req)
    public LoginResponse login(LoginRequest req) {
        // 1) 사용자 조회(이메일 기반이 일반적)
        // ⚠️ Repository 메서드명은 네가 SQL/백로그 보고 확정하는 룰이므로 여기선 TODO로 둠
        User user = /* TODO: userRepository.(...) */ null;

        // 2) 비밀번호 검증
        // if (!passwordEncoder.matches(req.getPassword(), user.getPassword())) throw ...

        // 3) access/refresh 발급
        String accessToken = tokenService.createAccessToken(/*userId*/ null, /*role*/ null);
        String refreshToken = tokenService.createRefreshToken(/*userId*/ null);

        // 4) refresh_token 테이블에 원문 저장 (rotation 전제)
        RefreshToken entity = new RefreshToken();
        // entity.setUserId(...)
        // entity.setToken(refreshToken)
        // entity.setExpiredAt(...)
        // entity.setCreatedAt(LocalDateTime.now())
        refreshTokenRepository.save(entity);

        LoginResponse res = new LoginResponse();
        // res.setAccessToken(accessToken)
        // res.setRefreshToken(refreshToken)
        // res.setUserId(...)
        // res.setRole(...)
        return res;
    }

    // ✅ 백로그: logout(accessToken)
    public void logout(String accessToken) {
        // 보통은 “현재 로그인 디바이스의 refreshToken”을 함께 받아서 지우는 게 가장 깔끔하지만
        // 백로그는 accessToken만 받게 되어있으니 아래 중 하나로 정책을 선택해야 함:
        //
        // A) accessToken에서 userId 추출 → 해당 userId의 refresh_token 전부 삭제 (전체 로그아웃)
        // B) accessToken 블랙리스트 테이블 운영 (지금 스키마엔 없음)
        //
        // MVP에선 A가 현실적.

        if (accessToken == null) return;

        Long userId = /* TODO: jwtProvider에서 userId 추출 */ null;

        // TODO: refreshTokenRepository.(userId 기반 삭제 메서드명 확정 후 적용)
        // refreshTokenRepository.deleteByUserId(userId);
    }

    // ✅ 백로그: refreshToken(req)
    public TokenResponse refreshToken(RefreshTokenRequest req) {
        // 1) 전달받은 refreshToken 원문
        String refreshToken = /* req.getRefreshToken() */ null;

        // 2) DB 존재 확인(탈취/로그아웃 토큰 방지)
        RefreshToken stored = /* TODO: refreshTokenRepository.(token으로 조회) */ null;

        // 3) refresh JWT 검증 (만료/서명)
        // TODO: jwtProvider.validateRefreshToken(refreshToken)

        // 4) 새 access 발급
        Long userId = /* TODO: refreshToken에서 userId */ null;
        String role = /* TODO: user에서 role */ null;
        String newAccess = tokenService.createAccessToken(userId, role);

        // 5) (권장) rotation: 기존 refresh 삭제 + 새 refresh 발급/저장
        // refreshTokenRepository.delete(stored);
        String newRefresh = tokenService.createRefreshToken(userId);
        RefreshToken newEntity = new RefreshToken();
        // newEntity.setUserId(userId)
        // newEntity.setToken(newRefresh)
        // newEntity.setExpiredAt(...)
        // newEntity.setCreatedAt(LocalDateTime.now())
        refreshTokenRepository.save(newEntity);

        TokenResponse res = new TokenResponse();
        // res.setAccessToken(newAccess)
        // res.setRefreshToken(newRefresh)
        return res;
    }
}
